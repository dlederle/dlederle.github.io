How does the highly iterative nature of good game design square with the requirements engineering / documentation that good software engineering demands?

Indeed, the rapidly changing nature of most game code, which is frequently re-inscribed and iterated on, is a good case study for much of the concerns of Parnas' software aging.


